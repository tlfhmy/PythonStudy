from math import sin
def f(x):
    return sin(x)+2.7182818**x

esp = 1e-10                                                 #设置误差限，即绝对值小于esp的两数当成“相等”。

root = []

domain = []                                                 #设置方程求解范围（对于可能多个根而言，需要求解域分离）
m = -10.
st = 0.33
while(m < 10.):                                         
    domain.append(m)
    m += st   

for i in domain:                                        
    if(f(i)*f(i+st) > esp):                                  #如果在这个足够小子区间内，函数在区间首尾乘积为正,函数无零点，故而无解
        continue                                            #所以用continue跳过
    elif(abs(f(i)*f(i+st)) < esp):                          #记住，我们有可能刚好选择到了f(i)或者f(i+st)是零，那么此时它们就会是方程的根。
        if(abs(f(i)) < esp):
            root.append(i)
            print(i)
        if(abs(f(i+st)) < esp):                             #这里为什么不用else？因为可能存在这种情况f(i)=f(i+0.5)=0
            root.append(i+st)
            print(i+st)                                       
    else:                                                   #else处的情况意味着一定存在解，以后是在判定有解的情况之后，如何求出近似解。
        tmpa = i                                            #暂存求解范围的区间端点值tmpa->左端点， tmpb->右端点。
        tmpb = i + st
        mid = (tmpa + tmpb)/2.                              #mid 求解区间的中点
        while(abs(f(mid)) > esp and (tmpb - tmpa) > esp):   #while语句是使用二分法求解方程在这个子区间的根。
            if (f(tmpa)*f(mid) > 0.):                       #如果前半部分，即tmpa到mid的部分，函数在这两点的积大于零，说明他们没有改变符号，所以在前半部分无解。
                tmpa = mid                                  #因此重设求解区间，将左端点移到mid处，右端点不变
                mid = (tmpa + tmpb)/2.                      #区间中点也会改变，重设为新的中点，从而接下来会在新区间内求解（因为根据判断，我们确定方程在这个区间内有解）。
            elif(f(tmpa)*f(mid) < 0.):                      #这是另一种情况，函数在前半部分有解，那么
                tmpb = mid                                  #保持区间左端点不变，右端点移至中点处
                mid = (tmpa + tmpb)/2.                      #重设中点为新的中点，再次循环求解.
            else:                                           #与之前类似，这里也有可能直接选到了mid使得f(mid)=0，那么mid就会是方程的根。
                root.append(mid)                           
        if(abs(f(mid)) < esp or tmpb-tmpa < esp):           #当函数值f(mid)小于误差限，就可以认为它是0，从而得到了根,或者解存在区间长度已经足够短(<esp)，
            root.append(mid)                                #则可认为里面的任意一点都是解(因为按前面所说，它们可认为相同)。
print(root)


#       二分法介绍：
#           想像一下，对于连续函数，如果存在否两个点，x1,x2使得f(x1)*f(x2)<0,即函数在两个地方拥有不同的符号，我们能够断言，
#        在这个区间[x1,x2]之内，肯定存在某个点x1<r<x2，使得f(r)=0;因为函数不可能跳跃过0点从负变为正或者从正变为负，因此，我们
#        可以通过每次将区间缩小一半的方法，来逼近方程的根。这就是二分法的核心思想。
#           现在我们来讲述一下如何进行二分法，我们已经确定了求解区间，即已经确定了两个值x1,x2使得f(x1)*f(x2)<0，这是前提！我们
#        可以找到它的中点m，然后分别判断这三种情况：
#                   1）f(x1)*f(m) > 0,这时候说明必须有f(m)*f(x2)<0,否则就会有f(x2)*f(x1)>0或=0了，这和我们的前提矛盾，因此
#                      在这种情况下，解必然存在于第二个区间，这时候我们将求解区间定位为后半个区间，区间长度因此减少了一半！
#                   2）f(x1)*f(m) < 0,和1）类似，只是这次解将定位于前半个区间，也会让解区间减少一半！
#                   3）f(x1)*f(m) = 0,那么m就已经是方程的根了。
#        我们循环这个过程，直到我们找到某个值m使得f(m)=0(近似求解中只需要f(x)的绝对值小于预先给定的精度就行)，此时我们就已经找到了解；
#        或者解的存在区间已经足够小，那么对于区间内的任意一个数，都可以当做方程的解。注意，因为我么事先已经确定了，在这个范围内存在解，所以
#        这个过程是可以停止下来的，即该算法是可停机的，是有效的算法。
#           不过这个算法也有它的缺点。首先，对于那种在求解区间内存在多个解的方程，我们只能找出其中的一个解；这个可以部分地解决，像我们现在的
#        程序这样，将区间分成足够小的区间，分别应用二分法，求解。但是这种解决方案在分解区间较小时，比费时费力。另一个就是，对于多项式而言，如果存在
#        多重根，例如f(x) = (x-1)^3*(x-2)^2*(x-3)，1是f(x)的3重根，2是f(x)的2重根，3是单根(即一重根)，这个方法不能求出根的重数。想要解决这
#        个问题，牵扯到另一种更加复杂的代数理论，可以设计一个多项式类，并在其中定义加减乘和带余数的除法（欧几里得算法），再运用二分法求解，便可求出
#        对应根的重数。


#        (^-^)要不要再自己试试，根据对算法的描述，重写代码；并计算(f(x)=x^4+5x^3+3x^2+x+1)的在区间[-5,5]零点，f(x)=sin(x)+e^(-x)在区间[-5,5]的零点（这个
#        方程有无穷多个解,而且在负半轴任意远处都存在该方程的解，所以求出它的一切解是不可能的）。